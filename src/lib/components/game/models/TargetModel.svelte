<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.1 -h -u -P -k -K -s target/scene.gltf
Author: zulubo (https://sketchfab.com/zulubo)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/pbr-target-ea1bec8a10054369862412c6d451e558
Title: PBR Target
-->

<script context="module">
	import { Group, Mesh } from 'three';
	import { T, forwardEventHandlers } from '@threlte/core';
	import { PositionalAudio, useGltf, useSuspense, Text } from '@threlte/extras';
	import { RigidBody } from '@threlte/rapier';

	const load = () => {
		const suspend = useSuspense();
		return suspend(useGltf('models/target/scene.gltf'));
	};

	export const preload = async () => {
		await load();
	};
</script>

<script lang="ts">
	import { AutoColliders } from '@threlte/rapier';
	import { SCORE, muted } from '$lib/store/game-config';
	import type { ContactEvent } from '@threlte/rapier';
	import ScoreUpdate from '../ScoreUpdate.svelte';
	import { clamp } from 'three/src/math/MathUtils';

	export const ref = new Group();
	let hit = false;

	let targetMesh: Mesh;

	let blink = true;

	let scored = false;

	let pointRef: Text;

	const gltf = load();

	let points = clamp(Math.floor($$restProps['position'][2]), 1, 100);

	const component = forwardEventHandlers();

	const target_hit_audio = {
		volume: 1,
		stop: undefined as (() => any) | undefined,
		play: undefined as ((...args: any[]) => any) | undefined,
		source: 'audio/target-hit.mp3'
	};

	const blinkTarget = () => {
		let callCount = 0;
		const intervalId = setInterval(() => {
			blink = !blink;
			callCount++;
			if (callCount == 5) {
				clearInterval(intervalId);
				hit = true;
			}
		}, 200); // Change visibility every 0.5 seconds
	};

	const contact = (e: ContactEvent) => {
		//Hit the floor
		if (e.targetRigidBody.userData['id'] === 'Floor') {
			return;
		} else {
			if (scored == false) {
				scored = true;
				if (!$muted) target_hit_audio?.play?.();
				SCORE.add(points);
				blinkTarget();
			}
		}
	};
</script>

{#if hit === false}
	<T is={ref} dispose={false} {...$$restProps} bind:this={$component} rotation.y={-Math.PI}>
		{#await gltf}
			<slot name="fallback" />
		{:then gltf}
			<T.Group name="TargetModel" rotation={[-Math.PI / 2, 0, 0]}>
				<T.Group name="CircleModel" rotation={[Math.PI / 2, 0, 0]}>
					<RigidBody userData={{ id: 'Target' }}>
						<AutoColliders shape="convexHull" mass={0.2} on:contact={contact}>
							<T.Mesh
								name="defaultMaterial"
								castShadow
								receiveShadow
								geometry={gltf.nodes.defaultMaterial.geometry}
								material={gltf.materials.target}
								bind:ref={targetMesh}
								visible={blink}
							/>
						</AutoColliders>
					</RigidBody>
				</T.Group>
			</T.Group>
		{:catch error}
			<slot name="error" {error} />
		{/await}
		<slot {ref} />
	</T>
{/if}

{#if scored}
	<ScoreUpdate {points} />
{/if}
<PositionalAudio
	autoplay={false}
	bind:stop={target_hit_audio.stop}
	bind:play={target_hit_audio.play}
	src={target_hit_audio.source}
	volume={target_hit_audio.volume}
/>
